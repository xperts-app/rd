<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Docin Secure â€” Files</title>
<style>
/* Simple responsive layout + sidebar */
:root{--accent:#0f62fe;--bg:#f6f8fb;--muted:#555;--card:#fff}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:var(--bg);color:#0b1220}
.app{display:flex;min-height:100vh}
.sidebar{width:260px;background:#fff;border-right:1px solid #e6e9ef;padding:14px;display:flex;flex-direction:column;gap:12px}
.brand{display:flex;gap:10px;align-items:center}
.logo{width:44px;height:44;border-radius:8px;background:linear-gradient(135deg,var(--accent),#66b1ff);display:flex;align-items:center;justify-content:center;color:white;font-weight:800}
.side-actions{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.main{flex:1;padding:14px}
.topbar{display:flex;gap:10px;align-items:center;margin-bottom:10px}
.btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;border:0;cursor:pointer}
.btn.ghost{background:#fff;color:var(--accent);border:1px solid #dfe7fb}
.controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
.search{flex:1;padding:8px;border-radius:9px;border:1px solid #dde7f9}
.files{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #eef2ff;display:flex;flex-direction:column;gap:8px}
.fname{font-weight:700}
.meta{font-size:12px;color:var(--muted)}
.actions{display:flex;gap:6px;margin-top:auto;flex-wrap:wrap}
.small{font-size:13px;color:var(--muted)}
.footer{margin-top:14px;font-size:13px;color:var(--muted)}
@media(max-width:800px){
  .sidebar{position:fixed;left:-280px;top:0;bottom:0;z-index:30;transition:left .22s;height:100vh;overflow:auto}
  .sidebar.open{left:0}
  .app.show-sidebar .overlay{display:block}
  .overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:20}
  .main{padding:12px}
}
.copy-btn{padding:6px 8px;border-radius:8px;border:1px solid #e6eefb;background:#fff;cursor:pointer}
</style>
</head>
<body>
<div class="app" id="app">
  <div class="sidebar" id="sidebar">
    <div class="brand">
      <div class="logo">Di</div>
      <div>
        <div style="font-weight:800">Docin Secure</div>
        <div style="font-size:13px;color:var(--muted)">Encrypted .docin</div>
      </div>
    </div>

    <div class="side-actions">
      <button id="newBtn" class="btn">+ New document</button>
      <label class="btn ghost" style="display:inline-flex;align-items:center;justify-content:center;gap:8px;cursor:pointer">
        Import .docin <input id="importFile" type="file" accept=".docin" style="display:none"/>
      </label>
      <button id="toggleSidebarClose" class="btn ghost" style="display:none">Close</button>
      <hr/>
      <button id="clearSession" class="btn ghost">Clear session passphrases</button>
      <div class="small">Tip: protect docs with a passphrase before exporting. If you share, send passphrase separately.</div>
    </div>
  </div>

  <div class="main">
    <div class="topbar">
      <button id="openSidebar" class="btn ghost" style="display:none">â˜°</button>
      <input id="search" class="search" placeholder="Search files..." />
      <div style="flex:1"></div>
      <button id="helpBtn" class="btn ghost">Security info</button>
    </div>

    <div id="list" class="files"></div>
    <div id="empty" class="footer" style="display:none">
      No documents yet â€” create one.
    </div>
  </div>

  <div class="overlay" id="overlay" onclick="document.getElementById('sidebar').classList.remove('open')"></div>
</div>

<script>
/* ====== Crypto utilities (PBKDF2 + AES-GCM) ====== */
const KDF_ITERATIONS = 200000; // adjustable
const AES_IV_BYTES = 12;
const STORAGE_KEY = 'docin_secure_store_v2';
const SESSION_PW_KEY = 'docin_session_pw_v2';

function strToBytes(s){ return new TextEncoder().encode(s); }
function bytesToStr(b){ return new TextDecoder().decode(b); }
function bytesToB64(b){
  let binary = ''; const arr = new Uint8Array(b);
  for (let i=0;i<arr.length;i++) binary += String.fromCharCode(arr[i]);
  return btoa(binary);
}
function b64ToBytes(s){ const bin = atob(s); const bytes = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i); return bytes; }
function randBytes(n){ const b = new Uint8Array(n); crypto.getRandomValues(b); return b; }

async function deriveKey(passphrase, saltB64, iterations=KDF_ITERATIONS){
  const salt = b64ToBytes(saltB64);
  const base = await crypto.subtle.importKey('raw', strToBytes(passphrase), {name:'PBKDF2'}, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations, hash:'SHA-256'}, base, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
  return key;
}

async function encryptWithPass(plainStr, pass){
  const salt = randBytes(16); const saltB64 = bytesToB64(salt);
  const key = await deriveKey(pass, saltB64);
  const iv = randBytes(AES_IV_BYTES);
  const enc = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, strToBytes(plainStr));
  const header = { v:1, kdf:{name:'PBKDF2', hash:'SHA-256', salt: saltB64, iterations: KDF_ITERATIONS}, alg:'AES-GCM', created: new Date().toISOString() };
  return bytesToB64(strToBytes(JSON.stringify(header))) + '.' + bytesToB64(new Uint8Array(iv.byteLength + enc.byteLength).map(()=>0)).replace(/^/, '') /* placeholder */;
  // We will build properly below to avoid memory growth. (placeholder removed in actual function below)
}
async function encryptPayload(plainStr, pass){
  const salt = randBytes(16); const saltB64 = bytesToB64(salt);
  const key = await deriveKey(pass, saltB64);
  const iv = randBytes(AES_IV_BYTES);
  const encBuf = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, strToBytes(plainStr));
  const header = { v:1, kdf:{name:'PBKDF2', hash:'SHA-256', salt: saltB64, iterations: KDF_ITERATIONS}, alg:'AES-GCM', created: new Date().toISOString() };
  const headerB64 = bytesToB64(strToBytes(JSON.stringify(header)));
  const full = new Uint8Array(iv.byteLength + encBuf.byteLength);
  full.set(iv,0); full.set(new Uint8Array(encBuf), iv.byteLength);
  const cipherB64 = bytesToB64(full);
  return headerB64 + '.' + cipherB64;
}

async function decryptPayload(payloadStr, pass){
  const parts = payloadStr.split('.');
  if (parts.length !== 2) throw new Error('Invalid payload');
  const headerJson = bytesToStr(b64ToBytes(parts[0]));
  const header = JSON.parse(headerJson);
  const saltB64 = header.kdf && header.kdf.salt;
  if (!saltB64) throw new Error('Missing salt in header');
  const key = await deriveKey(pass, saltB64, header.kdf.iterations || KDF_ITERATIONS);
  const full = b64ToBytes(parts[1]);
  const iv = full.slice(0, AES_IV_BYTES);
  const data = full.slice(AES_IV_BYTES);
  const dec = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, data);
  return bytesToStr(new Uint8Array(dec));
}

/* ====== storage helpers ====== */
function loadStore(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); }catch(e){return{}} }
function saveStore(m){ localStorage.setItem(STORAGE_KEY, JSON.stringify(m)); }
function sessionCacheGet(id){ try{ const m = JSON.parse(sessionStorage.getItem(SESSION_PW_KEY)||'{}'); return m[id] || null }catch(e){return null} }
function sessionCacheSet(id, pw){ try{ const m = JSON.parse(sessionStorage.getItem(SESSION_PW_KEY)||'{}'); m[id]=pw; sessionStorage.setItem(SESSION_PW_KEY, JSON.stringify(m)); }catch(e){} }
function sessionCacheClear(){ sessionStorage.removeItem(SESSION_PW_KEY); alert('Session passphrases cleared'); }

/* ====== app logic ====== */
const listEl = document.getElementById('list');
const searchEl = document.getElementById('search');
const importFile = document.getElementById('importFile');

function makeId(){ return 'd_' + Date.now() + '_' + Math.random().toString(36).slice(2,8); }
function nowIso(){ return new Date().toISOString(); }

function renderList(filter=''){
  const store = loadStore();
  const arr = Object.values(store).sort((a,b)=> b.modified.localeCompare(a.modified));
  listEl.innerHTML = '';
  if (arr.length===0) document.getElementById('empty').style.display='block'; else document.getElementById('empty').style.display='none';
  arr.filter(f=> f.name.toLowerCase().includes(filter.toLowerCase())).forEach(f=>{
    const card = document.createElement('div'); card.className='card';
    const name = document.createElement('div'); name.className='fname'; name.textContent = f.name + (f.protected ? ' ðŸ”’' : '');
    const meta = document.createElement('div'); meta.className='meta'; meta.textContent = 'Modified ' + new Date(f.modified).toLocaleString();
    const actions = document.createElement('div'); actions.className='actions';
    const openBtn = document.createElement('button'); openBtn.textContent='Open'; openBtn.className='btn ghost';
    openBtn.addEventListener('click', ()=> openFile(f.id));
    const protectBtn = document.createElement('button'); protectBtn.textContent = f.protected ? 'Change passphrase' : 'Protect'; protectBtn.className='btn ghost';
    protectBtn.addEventListener('click', ()=> protectFile(f.id));
    const expBtn = document.createElement('button'); expBtn.textContent='Export & Share'; expBtn.className='btn ghost';
    expBtn.addEventListener('click', ()=> exportAndShare(f.id));
    const delBtn = document.createElement('button'); delBtn.textContent='Delete'; delBtn.className='btn'; delBtn.style.background='#ef4444';
    delBtn.addEventListener('click', ()=> { if (!confirm('Delete '+f.name+'?')) return; const s=loadStore(); delete s[f.id]; saveStore(s); renderList(searchEl.value); });
    actions.appendChild(openBtn); actions.appendChild(protectBtn); actions.appendChild(expBtn); actions.appendChild(delBtn);
    card.appendChild(name); card.appendChild(meta); card.appendChild(actions);
    listEl.appendChild(card);
  });
}

async function createNew(){
  const id = makeId();
  const name = prompt('Document name','Untitled.docin') || 'Untitled.docin';
  const payload = JSON.stringify({version:1,id,name,modified: nowIso(), content: '<p></p>'});
  // encrypt with a random session passphrase, store encrypted locally
  const temp = '_local_' + Math.random().toString(36).slice(2);
  const enc = await encryptPayload(payload, temp);
  const store = loadStore();
  store[id] = { id, name, encrypted: enc, modified: nowIso(), protected: false };
  saveStore(store);
  sessionCacheSet(id, temp);
  // open editor
  location.href = '2.html?id=' + encodeURIComponent(id);
}

async function openFile(id){
  const store = loadStore(); const file = store[id];
  if (!file) return alert('Not found');
  // try cached passphrase
  const cached = sessionCacheGet(id);
  if (cached){
    try {
      const plain = await decryptPayload(file.encrypted, cached);
      sessionStorage.setItem('docin_open_'+id, plain);
      location.href = '2.html?id=' + encodeURIComponent(id);
      return;
    } catch(e){
      // clear cached and continue to prompt
      const m = JSON.parse(sessionStorage.getItem(SESSION_PW_KEY)||'{}'); delete m[id]; sessionStorage.setItem(SESSION_PW_KEY, JSON.stringify(m));
    }
  }
  const pass = prompt('Enter passphrase to open "'+file.name+'" (leave empty to cancel)');
  if (!pass) return;
  try {
    const plain = await decryptPayload(file.encrypted, pass);
    sessionStorage.setItem('docin_open_'+id, plain);
    sessionCacheSet(id, pass);
    location.href = '2.html?id=' + encodeURIComponent(id);
  } catch(e){
    alert('Wrong passphrase or file corrupted.');
  }
}

async function protectFile(id){
  const store = loadStore(); const file = store[id];
  if (!file) return alert('Not found');
  // decrypt using cached or ask
  let plain=null;
  const cached = sessionCacheGet(id);
  if (cached){
    try { plain = await decryptPayload(file.encrypted, cached); } catch(e){ /* ignore */ }
  }
  if (!plain){
    const cur = prompt('Enter current passphrase (leave empty if none):');
    if (cur===null) return;
    try { plain = await decryptPayload(file.encrypted, cur); sessionCacheSet(id, cur); } catch(e){ return alert('Cannot decrypt with provided passphrase.'); }
  }
  const newpw = prompt('Enter NEW passphrase for this file (leave empty to remove protection):');
  if (newpw===null) return;
  if (newpw.trim()===''){
    const temp = '_local_' + Math.random().toString(36).slice(2);
    const enc = await encryptPayload(plain, temp);
    file.encrypted = enc; file.protected = false; file.modified = nowIso();
    saveStore(store); sessionCacheSet(id, temp); renderList(searchEl.value); alert('Protection removed (session protected).');
  } else {
    const enc = await encryptPayload(plain, newpw);
    file.encrypted = enc; file.protected = true; file.modified = nowIso();
    saveStore(store); sessionCacheSet(id, newpw); renderList(searchEl.value); alert('Passphrase set.');
  }
}

async function exportAndShare(id){
  const store = loadStore(); const file = store[id];
  if (!file) return alert('Not found');
  // ask for passphrase to decrypt
  let plain=null;
  const cached = sessionCacheGet(id);
  if (cached){
    try { plain = await decryptPayload(file.encrypted, cached); } catch(e){ /* ignore */ }
  }
  if (!plain){
    const pw = prompt('Enter passphrase to decrypt for export (leave empty to cancel):');
    if (!pw) return;
    try { plain = await decryptPayload(file.encrypted, pw); sessionCacheSet(id, pw); } catch(e){ return alert('Wrong passphrase.'); }
  }
  // Ask whether set an export passphrase
  const protectExport = confirm('Protect exported file with a passphrase? (recommended)');
  let outPayload;
  let outPass;
  if (protectExport){
    outPass = prompt('Enter EXPORT passphrase (remember it):');
    if (outPass===null) return;
    outPayload = await encryptPayload(plain, outPass);
  } else {
    // still encrypt with random key so file is not plaintext
    outPass = null;
    const tmp = '_export_' + Math.random().toString(36).slice(2);
    outPayload = await encryptPayload(plain, tmp);
  }
  // create blob and offer download
  const blob = new Blob([outPayload], {type:'text/plain'});
  const filename = (file.name || 'docin') + '.docin';
  const url = URL.createObjectURL(blob);
  // try Web Share API to share file directly (mobile)
  if (navigator.canShare && navigator.canShare({files:[new File([blob], filename)]})){
    try {
      await navigator.share({files:[new File([blob], filename)], title: filename, text: 'Encrypted Docin file'});
      if (outPass) {
        if (confirm('Share passphrase via WhatsApp?')) sendPassViaWhatsApp(outPass, file.name);
      } else {
        alert('File shared. No passphrase set (file encrypted with random key). To let receiver open it use Export with passphrase.');
      }
      URL.revokeObjectURL(url);
      return;
    } catch(e){ /* fallback to download */ }
  }
  // fallback: create download link and show sharing options
  const a = document.createElement('a'); a.href=url; a.download = filename; document.body.appendChild(a);
  a.click(); a.remove();
  URL.revokeObjectURL(url);
  // offer passphrase sharing via WhatsApp or copy
  if (outPass){
    if (confirm('Exported and downloaded. Do you want to send the passphrase via WhatsApp now?')) sendPassViaWhatsApp(outPass, file.name);
  } else {
    if (confirm('Exported and downloaded. Note: no export passphrase set. You may want to protect exported file.')) {}
  }
}

function sendPassViaWhatsApp(pass, filename){
  const text = `Docin file "${filename}" passphrase: ${pass}\n\n(Do not share the passphrase in same channel as file if you want better security)`;
  // try web.whatsapp link (opens web/desktop/mobile)
  const encoded = encodeURIComponent(text);
  const wa = `https://wa.me/?text=${encoded}`;
  window.open(wa, '_blank');
}

/* import .docin from disk */
importFile.addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if (!f) return;
  const txt = await f.text();
  // prompt for passphrase
  const pw = prompt('Enter passphrase for the imported .docin (leave empty to cancel):');
  if (!pw) { e.target.value=''; return; }
  try {
    const plain = await decryptPayload(txt, pw);
    const parsed = JSON.parse(plain);
    const id = makeId();
    const temp = '_local_' + Math.random().toString(36).slice(2);
    const enc = await encryptPayload(plain, temp);
    const store = loadStore();
    store[id] = { id, name: parsed.name || f.name, encrypted: enc, modified: parsed.modified || nowIso(), protected: true };
    saveStore(store);
    sessionCacheSet(id, temp);
    alert('Imported as ' + store[id].name);
    renderList(searchEl.value);
  } catch(err){
    alert('Import failed: ' + (err.message || err));
  } finally { e.target.value=''; }
});

document.getElementById('newBtn').addEventListener('click', createNew);
document.getElementById('clearSession').addEventListener('click', sessionCacheClear);
document.getElementById('helpBtn').addEventListener('click', ()=> {
  alert('Security summary:\\n- Per-file passphrases (PBKDF2 SHA-256 -> AES-GCM 256)\\n- PBKDF2 iterations: ' + KDF_ITERATIONS + '\\n- If you lose passphrase, you cannot recover file.');
});
searchEl.addEventListener('input', ()=> renderList(searchEl.value));

/* mobile sidebar toggles */
const sidebar = document.getElementById('sidebar');
const openSidebar = document.getElementById('openSidebar');
const overlay = document.getElementById('overlay');
if (openSidebar){
  openSidebar.style.display = 'inline-block';
  openSidebar.addEventListener('click', ()=> { sidebar.classList.add('open'); overlay.style.display='block'; });
  document.getElementById('toggleSidebarClose').addEventListener('click', ()=> { sidebar.classList.remove('open'); overlay.style.display='none'; });
}

renderList();
</script>
</body>
</html>
